local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LP = Players.LocalPlayer

local Islands = {
	{N = "Dungeon", P = Vector3.new(10959.99, 134.04, 1250.57), I = "üè∞"},
	{N = "Alien Island", P = Vector3.new(2186.42, 35.82, 1302.21), I = "üëΩ"},
	{N = "Random Fruit", P = Vector3.new(2064.01, 36.25, 1093.72), I = "üçé"},
	{N = "Reset Race/Stats", P = Vector3.new(2052.92, 71.81, 1071.29), I = "üîÑ"},
	{N = "Fruit Shop", P = Vector3.new(2154.84, 79.04, 824.23), I = "üõí"},
	{N = "Sea Event", P = Vector3.new(2227.14, 362.20, -1205.43), I = "üåä"},
	{N = "Saber Lord", P = Vector3.new(1687.59, 289.10, -1166.54), I = "‚öîÔ∏è"},
	{N = "Awaken Fruit", P = Vector3.new(2066.98, 54.82, 551.41), I = "‚ú®"},
	{N = "Monkey Island", P = Vector3.new(3725.56, 45.42, 8813.90), I = "üêí"},
	{N = "Sea Beasts", P = Vector3.new(4543.48, 47.37, 11622.30), I = "üêâ"},
	{N = "Luma Forest", P = Vector3.new(-3935.36, 77.38, 6265.37), I = "üå≤"},
	{N = "Forgotten Arena", P = Vector3.new(-6105.61, 33.69, 1014.73), I = "üèüÔ∏è"},
	{N = "Drakenhole Fort", P = Vector3.new(6948.99, 49.78, -5753.79), I = "üê≤"},
}

local C = {
	bg = Color3.fromRGB(12, 12, 16),
	panel = Color3.fromRGB(20, 20, 26),
	card = Color3.fromRGB(28, 28, 36),
	cardH = Color3.fromRGB(38, 38, 50),
	accent = Color3.fromRGB(70, 130, 240),
	accentH = Color3.fromRGB(90, 150, 255),
	green = Color3.fromRGB(40, 180, 90),
	red = Color3.fromRGB(230, 55, 55),
	orange = Color3.fromRGB(240, 160, 30),
	text = Color3.fromRGB(235, 235, 245),
	dim = Color3.fromRGB(110, 110, 135),
	stroke = Color3.fromRGB(42, 42, 56),
	tab = Color3.fromRGB(18, 18, 24),
	tabActive = Color3.fromRGB(70, 130, 240),
	toggle_on = Color3.fromRGB(40, 180, 90),
	toggle_off = Color3.fromRGB(55, 55, 70),
	input = Color3.fromRGB(18, 18, 24),
}

local TI = {
	f = TweenInfo.new(0.1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
	s = TweenInfo.new(0.22, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
	o = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
	c = TweenInfo.new(0.18, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
	b = TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
}

local STATE = {
	open = true,
	tab = 1,
	flying = false,
	ghost = false,
	infJump = false,
	aura = false,
	baseWS = 16,
	flyConn = nil,
	jumpConn = nil,
	auraConn = nil,
	tping = false,
	lastTP = 0,
}

local function mk(cl, pr, ch)
	local i = Instance.new(cl)
	for k, v in pr do i[k] = v end
	if ch then for _, x in ch do x.Parent = i end end
	return i
end

local function rnd(p, r) return mk("UICorner", {CornerRadius = UDim.new(0, r or 8), Parent = p}) end
local function stk(p, c, t) return mk("UIStroke", {Color = c or C.stroke, Thickness = t or 1, Parent = p}) end
local function pad(p, t, b, l, r) return mk("UIPadding", {PaddingTop = UDim.new(0, t or 0), PaddingBottom = UDim.new(0, b or 0), PaddingLeft = UDim.new(0, l or 0), PaddingRight = UDim.new(0, r or 0), Parent = p}) end
local function tw(o, i, p) return TweenService:Create(o, i, p) end

local function press(b)
	local s = b.Size
	tw(b, TI.f, {Size = UDim2.new(s.X.Scale, s.X.Offset - 3, s.Y.Scale, s.Y.Offset - 2)}):Play()
	task.delay(0.06, function() tw(b, TI.b, {Size = s}):Play() end)
end

local function getRoot()
	local ch = LP.Character
	return ch and ch:FindFirstChild("HumanoidRootPart"), ch and ch:FindFirstChild("Humanoid")
end

local function safeTp(pos, name)
	if STATE.tping or tick() - STATE.lastTP < 0.4 then return end
	local root, hum = getRoot()
	if not root or not hum then return end
	STATE.tping = true
	STATE.lastTP = tick()
	if hum.SeatPart then hum.Sit = false task.wait(0.12) end
	root.Anchored = true
	task.wait(0.03)
	root.AssemblyLinearVelocity = Vector3.zero
	root.AssemblyAngularVelocity = Vector3.zero
	root.CFrame = CFrame.new(pos + Vector3.new(0, 2.5, 0))
	task.wait(0.08)
	root.AssemblyLinearVelocity = Vector3.zero
	root.AssemblyAngularVelocity = Vector3.zero
	root.Anchored = false
	pcall(function()
		local s = Instance.new("Sound")
		s.SoundId = "rbxassetid://6895079853"
		s.Volume = 0.35
		s.PlaybackSpeed = 1.3
		s.Parent = root
		s.PlayOnRemove = true
		s:Destroy()
	end)
	STATE.tping = false
	return true
end

local function deepSearch(parent, name, results, depth)
	if depth > 8 then return end
	for _, child in parent:GetChildren() do
		if child.Name:lower():find(name:lower(), 1, true) then
			local humanoid = child:FindFirstChildOfClass("Humanoid")
			local rootPart = child:FindFirstChild("HumanoidRootPart") or child:FindFirstChild("Head") or (child:IsA("BasePart") and child) or child:FindFirstChildWhichIsA("BasePart")
			if rootPart then
				local isPlayer = false
				for _, plr in Players:GetPlayers() do
					if plr.Character == child then isPlayer = true break end
				end
				if not isPlayer then
					table.insert(results, {name = child.Name, part = rootPart, model = child, hasHumanoid = humanoid ~= nil})
				end
			end
		end
		if child:IsA("Model") or child:IsA("Folder") or child:IsA("WorldModel") then
			deepSearch(child, name, results, depth + 1)
		end
	end
end

local function findNPC(name)
	local results = {}
	deepSearch(Workspace, name, results, 0)
	if #results == 0 then
		for _, v in Workspace:GetDescendants() do
			if v:IsA("BasePart") and v.Name:lower():find(name:lower(), 1, true) then
				table.insert(results, {name = v.Name, part = v, model = v.Parent, hasHumanoid = false})
			end
			if #results >= 10 then break end
		end
	end
	table.sort(results, function(a, b)
		local root = getRoot()
		if not root then return false end
		local dA = (a.part.Position - root.Position).Magnitude
		local dB = (b.part.Position - root.Position).Magnitude
		return dA < dB
	end)
	return results
end

local function tpToNPC(npcPart)
	local root = getRoot()
	if not root or not npcPart then return false end
	local npcPos = npcPart.Position
	local dir = (root.Position - npcPos).Unit
	if dir.Magnitude ~= dir.Magnitude then dir = Vector3.new(0, 0, 1) end
	local targetPos = npcPos + dir * 5
	targetPos = Vector3.new(targetPos.X, npcPos.Y, targetPos.Z)
	local success = safeTp(targetPos, npcPart.Name)
	if success then
		task.wait(0.1)
		local r2 = getRoot()
		if r2 then
			local lookAt = CFrame.lookAt(r2.Position, Vector3.new(npcPos.X, r2.Position.Y, npcPos.Z))
			r2.CFrame = lookAt
		end
	end
	return success
end

local GUI = mk("ScreenGui", {Name = "FlashTPBeta", ResetOnSpawn = false, ZIndexBehavior = Enum.ZIndexBehavior.Sibling, IgnoreGuiInset = false})
pcall(function() GUI.Parent = CoreGui end)
if not GUI.Parent then GUI.Parent = LP:WaitForChild("PlayerGui") end

local TogBtn = mk("TextButton", {Size = UDim2.new(0, 42, 0, 42), Position = UDim2.new(0, 14, 0.5, -21), BackgroundColor3 = C.accent, Text = "‚ö°", TextSize = 18, Font = Enum.Font.GothamBold, TextColor3 = C.text, AutoButtonColor = false, Visible = false, ZIndex = 10, Parent = GUI})
rnd(TogBtn, 21)
stk(TogBtn, C.accentH, 1.5)

local Main = mk("Frame", {Name = "Main", Size = UDim2.new(0, 220, 0, 380), Position = UDim2.new(0, 14, 0.5, -190), BackgroundColor3 = C.bg, BorderSizePixel = 0, ClipsDescendants = true, Parent = GUI})
rnd(Main, 12)
stk(Main, C.stroke, 1)

mk("ImageLabel", {Size = UDim2.new(1, 36, 1, 36), Position = UDim2.new(0.5, 0, 0.5, 4), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, Image = "rbxassetid://5554236805", ImageColor3 = Color3.new(0, 0, 0), ImageTransparency = 0.5, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(23, 23, 277, 277), ZIndex = -1, Parent = Main})

local TBar = mk("Frame", {Size = UDim2.new(1, 0, 0, 36), BackgroundColor3 = C.panel, BorderSizePixel = 0, Parent = Main})
rnd(TBar, 12)
mk("Frame", {Size = UDim2.new(1, 0, 0, 12), Position = UDim2.new(0, 0, 1, -12), BackgroundColor3 = C.panel, BorderSizePixel = 0, Parent = TBar})

local aLine = mk("Frame", {Size = UDim2.new(1, 0, 0, 2), Position = UDim2.new(0, 0, 1, 0), BackgroundColor3 = C.accent, BorderSizePixel = 0, Parent = TBar})
mk("UIGradient", {Color = ColorSequence.new(C.accent, C.accentH), Rotation = 0, Parent = aLine})

mk("TextLabel", {Size = UDim2.new(1, -50, 1, 0), Position = UDim2.new(0, 10, 0, 0), BackgroundTransparency = 1, Text = "‚ö° FLASH", TextColor3 = C.text, TextSize = 14, Font = Enum.Font.GothamBlack, TextXAlignment = Enum.TextXAlignment.Left, Parent = TBar})

mk("TextLabel", {Size = UDim2.new(0, 32, 0, 16), Position = UDim2.new(0, 72, 0.5, -8), BackgroundColor3 = C.accent, TextColor3 = C.text, Text = "Œ≤1.0", TextSize = 9, Font = Enum.Font.GothamBold, Parent = TBar}, {mk("UICorner", {CornerRadius = UDim.new(0, 4)})})

local XBtn = mk("TextButton", {Size = UDim2.new(0, 26, 0, 24), Position = UDim2.new(1, -32, 0.5, -12), BackgroundColor3 = C.bg, Text = "‚úï", TextColor3 = C.dim, TextSize = 11, Font = Enum.Font.GothamBold, AutoButtonColor = false, Parent = TBar})
rnd(XBtn, 6)
XBtn.MouseEnter:Connect(function() tw(XBtn, TI.f, {BackgroundColor3 = C.red, TextColor3 = C.text}):Play() end)
XBtn.MouseLeave:Connect(function() tw(XBtn, TI.f, {BackgroundColor3 = C.bg, TextColor3 = C.dim}):Play() end)

local TabBar = mk("Frame", {Size = UDim2.new(1, -12, 0, 28), Position = UDim2.new(0, 6, 0, 40), BackgroundColor3 = C.tab, BorderSizePixel = 0, Parent = Main})
rnd(TabBar, 6)

local TabLayout = mk("UIListLayout", {FillDirection = Enum.FillDirection.Horizontal, Padding = UDim.new(0, 2), HorizontalAlignment = Enum.HorizontalAlignment.Center, VerticalAlignment = Enum.VerticalAlignment.Center, Parent = TabBar})
pad(TabBar, 2, 2, 3, 3)

local tabs = {}
local pages = {}
local tabNames = {"üèùÔ∏è Island", "üë§ NPC", "‚öôÔ∏è Other"}

for idx, tn in tabNames do
	local tb = mk("TextButton", {Size = UDim2.new(0, 65, 0, 22), BackgroundColor3 = idx == 1 and C.tabActive or Color3.fromRGB(30, 30, 40), Text = tn, TextColor3 = idx == 1 and C.text or C.dim, TextSize = 10, Font = Enum.Font.GothamBold, AutoButtonColor = false, LayoutOrder = idx, Parent = TabBar})
	rnd(tb, 5)
	tabs[idx] = tb
end

local Content = mk("Frame", {Size = UDim2.new(1, 0, 1, -72), Position = UDim2.new(0, 0, 0, 72), BackgroundTransparency = 1, ClipsDescendants = true, Parent = Main})

local StatusLbl = mk("TextLabel", {Size = UDim2.new(1, -12, 0, 16), Position = UDim2.new(0, 6, 1, -18), BackgroundTransparency = 1, Text = "", TextColor3 = C.green, TextSize = 10, Font = Enum.Font.GothamBold, TextXAlignment = Enum.TextXAlignment.Left, TextTransparency = 1, ZIndex = 5, Parent = Main})

local function status(t, col)
	StatusLbl.Text = t
	StatusLbl.TextColor3 = col or C.green
	tw(StatusLbl, TI.f, {TextTransparency = 0}):Play()
	task.delay(2.2, function() tw(StatusLbl, TI.s, {TextTransparency = 1}):Play() end)
end

local P1 = mk("ScrollingFrame", {Name = "P1", Size = UDim2.new(1, -6, 1, -4), Position = UDim2.new(0, 3, 0, 2), BackgroundTransparency = 1, ScrollBarThickness = 2, ScrollBarImageColor3 = C.accent, CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y, BorderSizePixel = 0, Visible = true, Parent = Content})
mk("UIListLayout", {Padding = UDim.new(0, 4), HorizontalAlignment = Enum.HorizontalAlignment.Center, SortOrder = Enum.SortOrder.LayoutOrder, Parent = P1})
pad(P1, 2, 4, 0, 0)
pages[1] = P1

for i, loc in Islands do
	local btn = mk("TextButton", {Size = UDim2.new(1, -10, 0, 34), BackgroundColor3 = C.card, Text = "", AutoButtonColor = false, BorderSizePixel = 0, LayoutOrder = i, Parent = P1})
	rnd(btn, 7)
	mk("TextLabel", {Size = UDim2.new(0, 24, 1, 0), Position = UDim2.new(0, 5, 0, 0), BackgroundTransparency = 1, Text = loc.I, TextSize = 13, Parent = btn})
	mk("TextLabel", {Size = UDim2.new(1, -36, 1, 0), Position = UDim2.new(0, 28, 0, 0), BackgroundTransparency = 1, Text = loc.N, TextColor3 = C.text, TextSize = 11, Font = Enum.Font.GothamSemibold, TextXAlignment = Enum.TextXAlignment.Left, TextTruncate = Enum.TextTruncate.AtEnd, Parent = btn})
	btn.MouseEnter:Connect(function() tw(btn, TI.f, {BackgroundColor3 = C.cardH}):Play() end)
	btn.MouseLeave:Connect(function() tw(btn, TI.f, {BackgroundColor3 = C.card}):Play() end)
	btn.MouseButton1Click:Connect(function()
		press(btn)
		tw(btn, TI.f, {BackgroundColor3 = C.accent}):Play()
		task.delay(0.12, function() tw(btn, TI.s, {BackgroundColor3 = C.card}):Play() end)
		if safeTp(loc.P, loc.N) then status("‚úì " .. loc.N, C.green) else status("‚úó Failed", C.red) end
	end)
end

local P2 = mk("Frame", {Name = "P2", Size = UDim2.new(1, 0, 1, 0), BackgroundTransparency = 1, Visible = false, Parent = Content})
pages[2] = P2

local npcSearch = mk("Frame", {Size = UDim2.new(1, -12, 0, 30), Position = UDim2.new(0, 6, 0, 4), BackgroundColor3 = C.input, BorderSizePixel = 0, Parent = P2})
rnd(npcSearch, 7)
stk(npcSearch, C.stroke, 1)

mk("TextLabel", {Size = UDim2.new(0, 24, 1, 0), Position = UDim2.new(0, 4, 0, 0), BackgroundTransparency = 1, Text = "üîç", TextSize = 12, Parent = npcSearch})

local npcInput = mk("TextBox", {Size = UDim2.new(1, -64, 1, 0), Position = UDim2.new(0, 26, 0, 0), BackgroundTransparency = 1, PlaceholderText = "NPC name...", PlaceholderColor3 = C.dim, Text = "", TextColor3 = C.text, TextSize = 12, Font = Enum.Font.Gotham, TextXAlignment = Enum.TextXAlignment.Left, ClearTextOnFocus = false, Parent = npcSearch})

local npcGoBtn = mk("TextButton", {Size = UDim2.new(0, 30, 0, 22), Position = UDim2.new(1, -34, 0.5, -11), BackgroundColor3 = C.accent, Text = "GO", TextColor3 = C.text, TextSize = 10, Font = Enum.Font.GothamBold, AutoButtonColor = false, Parent = npcSearch})
rnd(npcGoBtn, 5)

local npcResultScroll = mk("ScrollingFrame", {Size = UDim2.new(1, -12, 1, -42), Position = UDim2.new(0, 6, 0, 38), BackgroundTransparency = 1, ScrollBarThickness = 2, ScrollBarImageColor3 = C.accent, CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y, BorderSizePixel = 0, Parent = P2})
mk("UIListLayout", {Padding = UDim.new(0, 3), HorizontalAlignment = Enum.HorizontalAlignment.Center, SortOrder = Enum.SortOrder.LayoutOrder, Parent = npcResultScroll})
pad(npcResultScroll, 2, 4, 0, 0)

local npcInfoLabel = mk("TextLabel", {Size = UDim2.new(1, -8, 0, 20), BackgroundTransparency = 1, Text = "Type NPC name & press GO", TextColor3 = C.dim, TextSize = 10, Font = Enum.Font.Gotham, LayoutOrder = 0, Parent = npcResultScroll})

local function clearNPCResults()
	for _, c in npcResultScroll:GetChildren() do
		if c:IsA("TextButton") then c:Destroy() end
	end
end

local function searchNPC()
	local query = npcInput.Text:gsub("^%s+", ""):gsub("%s+$", "")
	if #query < 2 then status("Min 2 chars", C.orange) return end
	clearNPCResults()
	npcInfoLabel.Text = "Searching..."
	npcInfoLabel.TextColor3 = C.orange

	task.defer(function()
		local results = findNPC(query)
		if #results == 0 then
			npcInfoLabel.Text = "No NPC found: \"" .. query .. "\""
			npcInfoLabel.TextColor3 = C.red
			status("‚úó Not found", C.red)
			return
		end
		npcInfoLabel.Text = #results .. " found"
		npcInfoLabel.TextColor3 = C.green

		for idx, r in results do
			if idx > 15 then break end
			local root = getRoot()
			local dist = root and math.floor((r.part.Position - root.Position).Magnitude) or 0
			local distStr = dist >= 1000 and string.format("%.1fk", dist / 1000) or tostring(dist)

			local rb = mk("TextButton", {Size = UDim2.new(1, -4, 0, 32), BackgroundColor3 = C.card, Text = "", AutoButtonColor = false, BorderSizePixel = 0, LayoutOrder = idx, Parent = npcResultScroll})
			rnd(rb, 6)

			mk("TextLabel", {Size = UDim2.new(0, 18, 1, 0), Position = UDim2.new(0, 4, 0, 0), BackgroundTransparency = 1, Text = r.hasHumanoid and "üë§" or "üì¶", TextSize = 11, Parent = rb})
			mk("TextLabel", {Size = UDim2.new(1, -70, 1, 0), Position = UDim2.new(0, 22, 0, 0), BackgroundTransparency = 1, Text = r.name, TextColor3 = C.text, TextSize = 11, Font = Enum.Font.GothamSemibold, TextXAlignment = Enum.TextXAlignment.Left, TextTruncate = Enum.TextTruncate.AtEnd, Parent = rb})
			local dLbl = mk("TextLabel", {Size = UDim2.new(0, 40, 0, 16), Position = UDim2.new(1, -46, 0.5, -8), BackgroundColor3 = C.bg, TextColor3 = C.dim, Text = distStr, TextSize = 9, Font = Enum.Font.GothamBold, Parent = rb})
			rnd(dLbl, 4)

			rb.MouseEnter:Connect(function() tw(rb, TI.f, {BackgroundColor3 = C.cardH}):Play() end)
			rb.MouseLeave:Connect(function() tw(rb, TI.f, {BackgroundColor3 = C.card}):Play() end)
			rb.MouseButton1Click:Connect(function()
				press(rb)
				tw(rb, TI.f, {BackgroundColor3 = C.accent}):Play()
				task.delay(0.12, function() tw(rb, TI.s, {BackgroundColor3 = C.card}):Play() end)
				if tpToNPC(r.part) then
					status("‚úì ‚Üí " .. r.name, C.green)
				else
					status("‚úó TP failed", C.red)
				end
			end)
		end
	end)
end

npcGoBtn.MouseButton1Click:Connect(function() press(npcGoBtn) searchNPC() end)
npcInput.FocusLost:Connect(function(enter) if enter then searchNPC() end end)
npcInput.Focused:Connect(function() local s = npcSearch:FindFirstChildOfClass("UIStroke") if s then tw(s, TI.f, {Color = C.accent}):Play() end end)
npcInput.FocusLost:Connect(function() local s = npcSearch:FindFirstChildOfClass("UIStroke") if s then tw(s, TI.f, {Color = C.stroke}):Play() end end)

local P3 = mk("ScrollingFrame", {Name = "P3", Size = UDim2.new(1, -6, 1, -4), Position = UDim2.new(0, 3, 0, 2), BackgroundTransparency = 1, ScrollBarThickness = 2, ScrollBarImageColor3 = C.accent, CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y, BorderSizePixel = 0, Visible = false, Parent = Content})
mk("UIListLayout", {Padding = UDim.new(0, 4), HorizontalAlignment = Enum.HorizontalAlignment.Center, SortOrder = Enum.SortOrder.LayoutOrder, Parent = P3})
pad(P3, 4, 6, 0, 0)
pages[3] = P3

local function mkToggle(parent, name, icon, order, callback)
	local frame = mk("Frame", {Size = UDim2.new(1, -10, 0, 34), BackgroundColor3 = C.card, BorderSizePixel = 0, LayoutOrder = order, Parent = parent})
	rnd(frame, 7)

	mk("TextLabel", {Size = UDim2.new(0, 22, 1, 0), Position = UDim2.new(0, 6, 0, 0), BackgroundTransparency = 1, Text = icon, TextSize = 12, Parent = frame})
	mk("TextLabel", {Size = UDim2.new(1, -70, 1, 0), Position = UDim2.new(0, 28, 0, 0), BackgroundTransparency = 1, Text = name, TextColor3 = C.text, TextSize = 11, Font = Enum.Font.GothamSemibold, TextXAlignment = Enum.TextXAlignment.Left, Parent = frame})

	local togBg = mk("Frame", {Size = UDim2.new(0, 36, 0, 18), Position = UDim2.new(1, -44, 0.5, -9), BackgroundColor3 = C.toggle_off, BorderSizePixel = 0, Parent = frame})
	rnd(togBg, 9)

	local togCircle = mk("Frame", {Size = UDim2.new(0, 14, 0, 14), Position = UDim2.new(0, 2, 0.5, -7), BackgroundColor3 = C.text, BorderSizePixel = 0, Parent = togBg})
	rnd(togCircle, 7)

	local on = false
	local btn = mk("TextButton", {Size = UDim2.new(1, 0, 1, 0), BackgroundTransparency = 1, Text = "", Parent = frame})

	btn.MouseButton1Click:Connect(function()
		on = not on
		if on then
			tw(togBg, TI.s, {BackgroundColor3 = C.toggle_on}):Play()
			tw(togCircle, TI.s, {Position = UDim2.new(0, 20, 0.5, -7)}):Play()
		else
			tw(togBg, TI.s, {BackgroundColor3 = C.toggle_off}):Play()
			tw(togCircle, TI.s, {Position = UDim2.new(0, 2, 0.5, -7)}):Play()
		end
		callback(on)
	end)

	return frame, function() return on end
end

local function mkSlider(parent, name, icon, order, min, max, default, callback)
	local frame = mk("Frame", {Size = UDim2.new(1, -10, 0, 48), BackgroundColor3 = C.card, BorderSizePixel = 0, LayoutOrder = order, Parent = parent})
	rnd(frame, 7)

	mk("TextLabel", {Size = UDim2.new(0, 22, 0, 20), Position = UDim2.new(0, 6, 0, 4), BackgroundTransparency = 1, Text = icon, TextSize = 12, Parent = frame})
	mk("TextLabel", {Size = UDim2.new(0, 80, 0, 20), Position = UDim2.new(0, 28, 0, 4), BackgroundTransparency = 1, Text = name, TextColor3 = C.text, TextSize = 11, Font = Enum.Font.GothamSemibold, TextXAlignment = Enum.TextXAlignment.Left, Parent = frame})

	local valLbl = mk("TextLabel", {Size = UDim2.new(0, 40, 0, 18), Position = UDim2.new(1, -48, 0, 5), BackgroundColor3 = C.bg, TextColor3 = C.accent, Text = tostring(default), TextSize = 10, Font = Enum.Font.GothamBold, Parent = frame})
	rnd(valLbl, 4)

	local track = mk("Frame", {Size = UDim2.new(1, -20, 0, 6), Position = UDim2.new(0, 10, 0, 32), BackgroundColor3 = C.bg, BorderSizePixel = 0, Parent = frame})
	rnd(track, 3)

	local fill = mk("Frame", {Size = UDim2.new((default - min) / (max - min), 0, 1, 0), BackgroundColor3 = C.accent, BorderSizePixel = 0, Parent = track})
	rnd(fill, 3)

	local knob = mk("Frame", {Size = UDim2.new(0, 14, 0, 14), Position = UDim2.new((default - min) / (max - min), -7, 0.5, -7), BackgroundColor3 = C.text, BorderSizePixel = 0, Parent = track})
	rnd(knob, 7)

	local sliding = false

	local function updateSlider(inputPos)
		local rel = math.clamp((inputPos.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
		local val = math.floor(min + rel * (max - min))
		fill.Size = UDim2.new(rel, 0, 1, 0)
		knob.Position = UDim2.new(rel, -7, 0.5, -7)
		valLbl.Text = tostring(val)
		callback(val)
	end

	track.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			sliding = true
			updateSlider(input.Position)
		end
	end)

	knob.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			sliding = true
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if sliding and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			updateSlider(input.Position)
		end
	end)

	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			sliding = false
		end
	end)

	return frame
end

mkSlider(P3, "Walk Speed", "üèÉ", 1, 16, 250, 16, function(val)
	STATE.baseWS = val
	local _, hum = getRoot()
	if hum then hum.WalkSpeed = val end
end)

mkToggle(P3, "Fly (Beta)", "üïäÔ∏è", 2, function(on)
	STATE.flying = on
	if on then
		local bp, bg
		STATE.flyConn = RunService.Heartbeat:Connect(function()
			local root, hum = getRoot()
			if not root then return end
			if not bp or not bp.Parent then
				bp = Instance.new("BodyPosition")
				bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
				bp.D = 100
				bp.P = 10000
				bp.Parent = root
				bg = Instance.new("BodyGyro")
				bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
				bg.D = 100
				bg.P = 10000
				bg.Parent = root
			end
			local cam = Workspace.CurrentCamera
			local mv = Vector3.zero
			if UserInputService:IsKeyDown(Enum.KeyCode.W) then mv = mv + cam.CFrame.LookVector end
			if UserInputService:IsKeyDown(Enum.KeyCode.S) then mv = mv - cam.CFrame.LookVector end
			if UserInputService:IsKeyDown(Enum.KeyCode.A) then mv = mv - cam.CFrame.RightVector end
			if UserInputService:IsKeyDown(Enum.KeyCode.D) then mv = mv + cam.CFrame.RightVector end
			if UserInputService:IsKeyDown(Enum.KeyCode.Space) then mv = mv + Vector3.new(0, 1, 0) end
			if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then mv = mv - Vector3.new(0, 1, 0) end
			if mv.Magnitude > 0 then mv = mv.Unit end
			bp.Position = root.Position + mv * 2.5
			bg.CFrame = cam.CFrame
		end)
		status("Fly ON", C.green)
	else
		if STATE.flyConn then STATE.flyConn:Disconnect() STATE.flyConn = nil end
		local root = getRoot()
		if root then
			for _, v in root:GetChildren() do
				if v:IsA("BodyPosition") or v:IsA("BodyGyro") then v:Destroy() end
			end
		end
		status("Fly OFF", C.dim)
	end
end)

mkToggle(P3, "Inf Jump", "‚¨ÜÔ∏è", 3, function(on)
	STATE.infJump = on
	if on then
		STATE.jumpConn = UserInputService.JumpRequest:Connect(function()
			local _, hum = getRoot()
			if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
		end)
		status("Inf Jump ON", C.green)
	else
		if STATE.jumpConn then STATE.jumpConn:Disconnect() STATE.jumpConn = nil end
		status("Inf Jump OFF", C.dim)
	end
end)

mkToggle(P3, "Ghost (Noclip)", "üëª", 4, function(on)
	STATE.ghost = on
	if on then
		STATE.ghostConn = RunService.Stepped:Connect(function()
			local ch = LP.Character
			if not ch then return end
			for _, p in ch:GetDescendants() do
				if p:IsA("BasePart") then p.CanCollide = false end
			end
		end)
		status("Ghost ON", C.green)
	else
		if STATE.ghostConn then STATE.ghostConn:Disconnect() STATE.ghostConn = nil end
		local ch = LP.Character
		if ch then
			for _, p in ch:GetDescendants() do
				if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then p.CanCollide = true end
			end
		end
		status("Ghost OFF", C.dim)
	end
end)

mkToggle(P3, "Aura Sim (DV4)", "üòà", 5, function(on)
	STATE.aura = on
	if on then
		local particles = {}
		STATE.auraConn = RunService.Heartbeat:Connect(function()
			local root = getRoot()
			if not root then return end
			if not root:FindFirstChild("AuraEffect") then
				local att = Instance.new("Attachment")
				att.Name = "AuraEffect"
				att.Parent = root

				local p1 = Instance.new("ParticleEmitter")
				p1.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 0, 160)),
					ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 0, 50)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 60, 0)),
				}
				p1.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 0)}
				p1.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)}
				p1.Lifetime = NumberRange.new(0.4, 0.8)
				p1.Rate = 60
				p1.Speed = NumberRange.new(3, 6)
				p1.SpreadAngle = Vector2.new(30, 30)
				p1.Acceleration = Vector3.new(0, 8, 0)
				p1.RotSpeed = NumberRange.new(-200, 200)
				p1.LightEmission = 0.8
				p1.LightInfluence = 0.2
				p1.Parent = att
				table.insert(particles, p1)

				local p2 = Instance.new("ParticleEmitter")
				p2.Color = ColorSequence.new(Color3.fromRGB(255, 0, 60))
				p2.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0)}
				p2.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 1)}
				p2.Lifetime = NumberRange.new(0.2, 0.5)
				p2.Rate = 40
				p2.Speed = NumberRange.new(1, 3)
				p2.SpreadAngle = Vector2.new(360, 360)
				p2.LightEmission = 1
				p2.Parent = att
				table.insert(particles, p2)

				local light = Instance.new("PointLight")
				light.Name = "AuraLight"
				light.Color = Color3.fromRGB(160, 0, 80)
				light.Brightness = 2
				light.Range = 15
				light.Parent = root
			end
		end)
		status("Aura DV4 ON", C.green)
	else
		if STATE.auraConn then STATE.auraConn:Disconnect() STATE.auraConn = nil end
		local root = getRoot()
		if root then
			local att = root:FindFirstChild("AuraEffect")
			if att then att:Destroy() end
			local lt = root:FindFirstChild("AuraLight")
			if lt then lt:Destroy() end
		end
		status("Aura OFF", C.dim)
	end
end)

local function switchTab(idx)
	if STATE.tab == idx then return end
	STATE.tab = idx
	for i, tb in tabs do
		tw(tb, TI.s, {BackgroundColor3 = i == idx and C.tabActive or Color3.fromRGB(30, 30, 40), TextColor3 = i == idx and C.text or C.dim}):Play()
	end
	for i, pg in pages do
		if i == idx then
			pg.Visible = true
			pg.Position = UDim2.new(0.05, 0, 0, 2)
			tw(pg, TI.s, {Position = i == 1 and UDim2.new(0, 3, 0, 2) or UDim2.new(0, 0, 0, 0)}):Play()
		else
			pg.Visible = false
		end
	end
end

for i, tb in tabs do
	tb.MouseButton1Click:Connect(function() press(tb) switchTab(i) end)
end

local function toggleUI()
	STATE.open = not STATE.open
	if STATE.open then
		Main.Visible = true
		Main.Size = UDim2.new(0, 220, 0, 0)
		tw(Main, TI.o, {Size = UDim2.new(0, 220, 0, 380)}):Play()
		TogBtn.Visible = false
	else
		tw(Main, TI.c, {Size = UDim2.new(0, 220, 0, 0)}):Play()
		task.delay(0.18, function()
			if not STATE.open then Main.Visible = false TogBtn.Visible = true end
		end)
	end
end

XBtn.MouseButton1Click:Connect(function() press(XBtn) toggleUI() end)
TogBtn.MouseButton1Click:Connect(function() press(TogBtn) toggleUI() end)

do
	local dg, di, ds, sp
	local function upd(input) local d = input.Position - ds Main.Position = UDim2.new(sp.X.Scale, sp.X.Offset + d.X, sp.Y.Scale, sp.Y.Offset + d.Y) end
	TBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dg = true ds = input.Position sp = Main.Position
			input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dg = false end end)
		end
	end)
	TBar.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then di = input end end)
	UserInputService.InputChanged:Connect(function(input) if input == di and dg then upd(input) end end)
end

do
	local dg2, di2, ds2, sp2
	local function upd2(input) local d = input.Position - ds2 TogBtn.Position = UDim2.new(sp2.X.Scale, sp2.X.Offset + d.X, sp2.Y.Scale, sp2.Y.Offset + d.Y) end
	TogBtn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dg2 = true ds2 = input.Position sp2 = TogBtn.Position
			input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dg2 = false end end)
		end
	end)
	TogBtn.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then di2 = input end end)
	UserInputService.InputChanged:Connect(function(input) if input == di2 and dg2 then upd2(input) end end)
end

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.RightControl then toggleUI() end
end)

LP.CharacterAdded:Connect(function(char)
	char:WaitForChild("Humanoid").WalkSpeed = STATE.baseWS
end)

Main.Size = UDim2.new(0, 220, 0, 0)
task.wait(0.12)
tw(Main, TI.o, {Size = UDim2.new(0, 220, 0, 380)}):Play()
